/* The first section of a bison file contains:
 *    1. A code section for includes and other arbitrary C code. Copied to the parser verbatim
 *    2. Definition of the yylval union
 *    3. Definition of the tokens
 *    4. Precedence directives
 *    5. The start token
 *    6. Parser options
 */

/* Code section */
%{
#include <stdio.h>
#include <stdlib.h>

// Reference to the line number generated by the scanner
extern int yylineno;
// Reference to the yylex function to quiet a compiler warning
int yylex();

// The yyerror function is called on any syntax error. When using %error-verbose, this function
// takes a single argument (a string) which contains a detailed explanation of the error.
// Otherwise it takes no arguments and it is up to the user to format the error using a minimal
// description provided in yytext.
void yyerror(const char *s) {
	fprintf(stderr, "Error: (line %d) %s\n", yylineno, s);
	exit(1);
}

%}

/* The union directive defines the yylval union used for associating (a) terminals (tokens)
 * returned by flex with additional scanning data (such as identifier/constant values); and
 * optionally (b) non-terminals (variables in productions) with AST information if any.
 */
%union {
	int intval;
  float floatval;
	char *stringval;
}

%token <intval> tINTVAL
%token <boolval> tBOOLVAL
%token <floatval> tFLOATVAL
%token <stringval> tSTRINGVAL
%token <stringval> tIDENTIFIER 
%token <stringval> tCOMMENT

%token 
	tVAR tBOOL tFLOAT tINT tSTRING  
  tIF tELSE tPRINT tREAD tWHILE 
  tBINEQ tBINNEQ tBINAND tBINOR

%left tBINOR
%left tBINAND
%left tBINEQ tBINNEQ
%left '+' '-'
%left '*' '/'
%left '(' ')'
%left '!'


/* Start token (by default if this is missing it takes the first production */
%start prog

/* Generate the yylloc structure used for storing line numbers with tokens */
%locations
/* Generate detailed error messages */
%error-verbose

/* The second section of a bison file contains the productions. Note that rules with the
 * same LHS may be joined together and separated with a pipe.
 */
%% 

prog: dclrs stmts 
    ;

stmts: /* epsilon */
    | stmt stmts
    ;
  
stmt: tREAD tIDENTIFIER ';'
    | tPRINT exp ';'
    | tIDENTIFIER '=' exp ';'
    | tIF exp '{' stmts '}' tELSE '{' stmts '}'
    | tIF exp '{' stmts '}'
    | tWHILE exp '{' stmts '}'
    ;

dclrs:  /*epsilon*/ 
    |  dclr dclrs
    ;

dclr: tCOMMENT
    | tVAR tIDENTIFIER ':' type '=' exp ';'
    ;

type: tBOOL |
      tFLOAT |
      tINT |
	  tSTRING
      ; 

exp : tIDENTIFIER
    | tSTRINGVAL
    | tBOOLVAL
    | tFLOATVAL
    | tINTVAL 
    | exp '*' exp     
    | exp '/' exp 
    | exp '+' exp 
    | exp '-' exp
    | '(' exp ')'
    | exp tBINEQ exp
    | exp tBINNEQ exp
    | exp tBINAND exp
    | exp tBINOR exp 
    | '!' exp
    | unarymin
    ;


unarymin: '-' exp
    ;

%%

